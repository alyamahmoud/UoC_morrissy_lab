---
title: "SCENIC"
author: "am"
date: "29/11/2019"
output: html_document
---
```{r}
# https://rstudio.github.io/reticulate/articles/python_packages.html
library (reticulate)
use_condaenv('scenic_protocol', required = TRUE)
```

```{r}
#devtools::install_github("aertslab/SCENIC@v1.1.1") 
suppressPackageStartupMessages({
  library (data.table)
  library(extrafont)
  library(SCENIC)
  library(AUCell)
  library(RcisTarget)
  library(SCopeLoomR)
  library(Seurat)
  library (tibble)
  library (dplyr)
  library (tidyr)
  library (tibble)
  library (stringr)
  library (igraph)
  library (scales)
  library (ggplot2)
  library (leiden)
  library(RColorBrewer)
  library(qgraph)
})
```

```{r}
# import modules
reticulate::import("pandas")
reticulate::import ('numpy')
reticulate::import ('glob')
reticulate::import ('pickle')
py_run_string('from arboreto.utils import load_tf_names')
py_run_string('from arboreto.algo import grnboost2')
py_run_string('from pyscenic.rnkdb import FeatherRankingDatabase as RankingDatabase')
py_run_string('from pyscenic.utils import modules_from_adjacencies, load_motifs')
py_run_string('from pyscenic.prune import prune2df, df2regulons')
py_run_string('from pyscenic.aucell import aucell')
reticulate:: import('seaborn')

```

```{r}
# read adjacency matrix as pickle data
getwd()
adj <- py_load_object('../data/adjacencies_test.dataframe')
regulons <- py_load_object('../data/regulons_asIncidMat') # 2.5
regulomes <- read.csv('../data/regulomes_test.csv', header = TRUE)
regulonTargetsInfo <- read.csv ('../data/auc_scores.csv', header = TRUE)
regulonAUC <- read.csv('../data/auc_mtx.csv')
# alternative method
# require ('reticulate')
#source_python('../scripts/pickle_reader.py')
#regulons <- read_pickle_file('../data/regulons_asIncidMat')

```

```{r}
# read table with unequal number of columsn (TF-targets)
# https://sites.psu.edu/biomonika/2017/09/08/reading-text-files-with-variable-number-of-columns-in-r/
no_col <- max(count.fields('../data/Tf2targets.csv', sep = ","))
Tf_target <- read.table('../data/Tf2targets.csv',sep=",",fill=TRUE,header = F,col.names=c("chr", "start", "end", "length",1:no_col))

rownames(Tf_target) = Tf_target$chr; Tf_target = Tf_target[,-1]

# convert to list (r object)
regulons <- as.list(as.data.frame(t(Tf_target)))

# convert 2.5_regulons_asGeneSet to 2.6_regulons_asIncidMat
incidList <- reshape2::melt(regulons)
incidList <- incidList[!incidList$value == "", ]; incidList <- na.omit(incidList)
incidMat <- table(incidList[,2], incidList[,1])

# TODO NMF::aheatmap(incidMat)
# TODO complex heatmap
#saveRDS(incidMat, file=getIntName(scenicOptions, "regulons_incidMat"))
length(regulons) 
#summary(lengths(regulons))
```

```{r}
# read in seurat object
brain_data_A <- readRDS ('../data/brain.data.A.Rds')
```

```{r}
# append cell assign annotation
cell_assign <- read.csv('../data/cell_assign_annotation.csv'); cell_assign = cell_assign[,-1]
cell_types = cell_assign$cell_type
names(cell_types) = cell_assign$barcode
brain_data_A <- AddMetaData(
  object = brain_data_A, metadata = cell_types, col.name= 'cell_types'
)
colnames(brain_data_A@meta.data)[5] = c('time_point')
```

```{r}
# average regulon activity by cell type or seurat clusters
# seurat clusters
cellInfo <- brain_data_A@meta.data
rownames(regulonAUC) = regulonAUC[,1]; regulonAUC = regulonAUC[,-1]
regulonAUC <- regulonAUC[onlyNonDuplicatedExtended(rownames(regulonAUC)),]
regulonActivity_byCluster <- NULL; 
regulonActivity_byCluster <- sapply(split(rownames(cellInfo), cellInfo$seurat_clusters), function(cells) rowMeans(t(regulonAUC)[,cells]))

regulonActivity_byCluster_Scaled <- t(scale(t(regulonActivity_byCluster), center = T, scale=T))

pdf ('../plots/brain_data_A_seurat_clusters.pdf', width  = 8, height = 15 )
pheatmap::pheatmap(regulonActivity_byCluster_Scaled, #fontsize_row=3, 
                   color=colorRampPalette(c("blue","white","red"))(100), breaks=seq(-3, 3, length.out = 100),fontsize_row = 3,
                   treeheight_row=10, treeheight_col=10, border_color=NA, clustering_method = 'ward.D2')
dev.off()

# cell types
regulonActivity_byCellType <- NULL; 
regulonActivity_byCellType <- sapply(split(rownames(cellInfo), cellInfo$cell_types), function(cells) rowMeans(t(regulonAUC)[,cells]))

regulonActivity_byCellType_Scaled <- t(scale(t(regulonActivity_byCellType), center = T, scale=T))

pdf ('../plots/brain_data_A_cell_types.pdf', width  = 8, height = 20)
pheatmap::pheatmap(regulonActivity_byCellType_Scaled, #fontsize_row=3, 
                   color=colorRampPalette(c("blue","white","red"))(100), breaks=seq(-3, 3, length.out = 100), fontsize_row = 3, 
                   treeheight_row=10, treeheight_col=10, border_color=NA, clustering_method = 'ward.D2')
dev.off()
```
```{r}
# extracting cluster-specific regulons
regulonActivity_byCluster <- data.frame (regulonActivity_byCluster)

x0 <- regulonActivity_byCluster[regulonActivity_byCluster$X0 > quantile(regulonActivity_byCluster$X0) [4], ]; x0 <- rownames(x0)

x1 <- regulonActivity_byCluster[regulonActivity_byCluster$X1 > quantile(regulonActivity_byCluster$X1) [4], ]; x1 <- rownames(x1)

x2 <- regulonActivity_byCluster[regulonActivity_byCluster$X2 > quantile(regulonActivity_byCluster$X2) [4], ]; x2 <- rownames(x2)

x3 <- regulonActivity_byCluster[regulonActivity_byCluster$X3 > quantile(regulonActivity_byCluster$X3) [4], ]; x3 <- rownames(x3)

x4 <- regulonActivity_byCluster[regulonActivity_byCluster$X4 > quantile(regulonActivity_byCluster$X4) [4], ]; x4 <- rownames(x4)

x5 <- regulonActivity_byCluster[regulonActivity_byCluster$X5 > quantile(regulonActivity_byCluster$X5) [4], ]; x5 <- rownames(x5)

x6 <- regulonActivity_byCluster[regulonActivity_byCluster$X6 > quantile(regulonActivity_byCluster$X6) [4], ]; x6 <- rownames(x6)

x7 <- regulonActivity_byCluster[regulonActivity_byCluster$X7 > quantile(regulonActivity_byCluster$X7) [4], ]; x7 <- rownames(x7)

x8 <- regulonActivity_byCluster[regulonActivity_byCluster$X8 > quantile(regulonActivity_byCluster$X8) [4], ]; x8 <- rownames(x8)

x9 <- regulonActivity_byCluster[regulonActivity_byCluster$X9 > quantile(regulonActivity_byCluster$X9) [4], ]; x9 <- rownames(x9)

x10 <- regulonActivity_byCluster[regulonActivity_byCluster$X10 > quantile(regulonActivity_byCluster$X10) [4], ]; x10 <- rownames(x10)

x11 <- regulonActivity_byCluster[regulonActivity_byCluster$X11 > quantile(regulonActivity_byCluster$X11) [4], ]; x11 <- rownames(x11)

x12 <- regulonActivity_byCluster[regulonActivity_byCluster$X12 > quantile(regulonActivity_byCluster$X12) [4], ]; x12 <- rownames(x12)

x13 <- regulonActivity_byCluster[regulonActivity_byCluster$X13 > quantile(regulonActivity_byCluster$X13) [4], ]; x13 <- rownames(x13)

x14 <- regulonActivity_byCluster[regulonActivity_byCluster$X14 > quantile(regulonActivity_byCluster$X14) [4], ]; x14 <- rownames(x14)

x15 <- regulonActivity_byCluster[regulonActivity_byCluster$X15 > quantile(regulonActivity_byCluster$X15) [4], ]; x15 <- rownames(x15)

x16 <- regulonActivity_byCluster[regulonActivity_byCluster$X16 > quantile(regulonActivity_byCluster$X16) [4], ]; x16 <- rownames(x16)

x17 <- regulonActivity_byCluster[regulonActivity_byCluster$X17 > quantile(regulonActivity_byCluster$X17) [4], ]; x17 <- rownames(x17)

x18 <- regulonActivity_byCluster[regulonActivity_byCluster$X18 > quantile(regulonActivity_byCluster$X18) [4], ]; x18 <- rownames(x18)

x19 <- regulonActivity_byCluster[regulonActivity_byCluster$X19 > quantile(regulonActivity_byCluster$X19) [4], ]; x19 <- rownames(x19)

x20 <- regulonActivity_byCluster[regulonActivity_byCluster$X20 > quantile(regulonActivity_byCluster$X20) [4], ]; x20 <- rownames(x20)

x21 <- regulonActivity_byCluster[regulonActivity_byCluster$X21 > quantile(regulonActivity_byCluster$X21) [4], ]; x21 <- rownames(x21)

x22 <- regulonActivity_byCluster[regulonActivity_byCluster$X22 > quantile(regulonActivity_byCluster$X22) [4], ]; x22 <- rownames(x22)

x23 <- regulonActivity_byCluster[regulonActivity_byCluster$X23 > quantile(regulonActivity_byCluster$X23) [4], ]; x23 <- rownames(x23)

x24 <- regulonActivity_byCluster[regulonActivity_byCluster$X24 > quantile(regulonActivity_byCluster$X24) [4], ]; x24 <- rownames(x24)
```

```{r}
# visualise unique vs shared regulons
library (UpSetR)
listInput <- list (cluster0=x0, cluster1=x1, cluster2=x2, cluster3=x3, cluster4=x4, cluster5=x5, cluster6=x6, cluster7=x7, cluster8=x8, cluster9=x9, cluster10=x10, cluster11=x11, cluster12=x12, cluster13=x13, cluster14=x14, cluster15=x15, cluster16=x16, cluster17=x17, cluster18=x18, cluster19=x19, cluster20=x20, cluster21=x21, cluster22=x22, cluster23=x23, cluster24=x24)
pdf ('../plots/regulons_byCluster.pdf', width = 8, height = 8)
upset(fromList(listInput), nsets = 25, order.by = "freq", point.size = 2, number.angles = 30, mainbar.y.label = 'regulons per seurat cluster')
dev.off()
```

```{r}
# extracting cell type specific regulons
regulonActivity_byCellType <- data.frame (regulonActivity_byCellType)

Astrocytes.Bergmann.glia <- regulonActivity_byCellType[regulonActivity_byCellType$Astrocytes.Bergmann.glia > quantile(regulonActivity_byCellType$Astrocytes.Bergmann.glia) [4], ]; Astrocytes.Bergmann.glia <- rownames(Astrocytes.Bergmann.glia)

# visualise cell types shared and specific regulons
listInput <- list (Astrocyte.Bergmann.glia.prec=Astrocyte.Bergmann.glia.prec, Astrocytes.Bergmann.glia=Astrocytes.Bergmann.glia, Brainstem.prog=Brainstem.prog, Diff.GABA.interneu=Diff.GABA.interneu, Diff.granule.c.=Diff.granule.c., Diff.Purkinje.c.=Diff.Purkinje.c., Embryonic.GCPs=Embryonic.GCPs, Endothelial.c.=Endothelial.c., Excitatory.cerebellar.nuclei.neu=Excitatory.cerebellar.nuclei.neu, GABA.interneu=GABA.interneu, GABA.interneuron.prec=GABA.interneuron.prec, Gliogenic.prog=Gliogenic.prog, Glutamatergic.neu=Glutamatergic.neu, Granule.c.=Granule.c., Meninges=Meninges, Mesenchymal.stem.c.=Mesenchymal.stem.c., Microglia=Microglia, Myelinating.oligodendrocytes=Myelinating.oligodendrocytes, Neural.stem.c.=Neural.stem.c., Oligodendrocyte.precursor.c.=Oligodendrocyte.precursor.c., Pericytes=Pericytes, Post.GCPs.1=Post.GCPs.1, Post.GCPs.2=Post.GCPs.2, Post.gliogenic.prog=Post.gliogenic.prog, Post.glutamatergic.neu=Post.glutamatergic.neu, Proliferating.VZ.prog=Proliferating.VZ.prog, Purkinje.c.=Purkinje.c., Red.blood.c.=Red.blood.c., Roof.plate.like.stem.c.=Roof.plate.like.stem.c., UniBC.and.GCP.progenitor=UniBC.and.GCP.progenitor, Unipolar.brush.c.=Unipolar.brush.c., Upper.rhombic.lip.prog=Upper.rhombic.lip.prog, VZ.prog=VZ.prog)
pdf ('../plots/regulons_byCellType.pdf', width = 10, height = 12)
upset(fromList(listInput), nsets = 33, order.by = "freq", point.size = 2.5, number.angles = 30, mainbar.y.label = 'regulons per cell type')
dev.off()
```


```{r}
# compare to AUC/regulons derived from the individual time points
e10a <- read.csv('../data/individual_time_points/e10A/auc_mtx.csv'); e10a <- column_to_rownames(e10a, var = 'Cell'); 
e11a <- read.csv('../data/individual_time_points/e11A/auc_mtx.csv'); e11a <- column_to_rownames(e11a, var = 'Cell'); 
e12a <- read.csv('../data/individual_time_points/e12A/auc_mtx.csv'); e12a <- column_to_rownames(e12a, var = 'Cell'); 
e13a <- read.csv('../data/individual_time_points/e13A/auc_mtx.csv'); e13a <- column_to_rownames(e13a, var = 'Cell'); 
e14a <- read.csv('../data/individual_time_points/e14A/auc_mtx.csv'); e14a <- column_to_rownames(e14a, var = 'Cell'); 
e15a <- read.csv('../data/individual_time_points/e15A/auc_mtx.csv'); e15a <- column_to_rownames(e15a, var = 'Cell'); 
e16a <- read.csv('../data/individual_time_points/e16A/auc_mtx.csv'); e16a <- column_to_rownames(e16a, var = 'Cell'); 
e17a <- read.csv('../data/individual_time_points/e17A/auc_mtx.csv'); e17a <- column_to_rownames(e17a, var = 'Cell'); 
P00a <- read.csv('../data/individual_time_points/P0OA/auc_mtx.csv'); P00a <- column_to_rownames(P00a, var = 'Cell'); 
P04a <- read.csv('../data/individual_time_points/P04A/auc_mtx.csv'); P04a <- column_to_rownames(P04a, var = 'Cell'); 
P07a <- read.csv('../data/individual_time_points/P07A/auc_mtx.csv'); P07a <- column_to_rownames(P07a, var = 'Cell'); 
P10a <- read.csv('../data/individual_time_points/P10A/auc_mtx.csv'); P10a <- column_to_rownames(P10a, var = 'Cell');

e10a <- t(e10a)
e11a <- t(e11a)
e12a <- t(e12a)
e13a <- t(e13a)
e14a <- t(e14a)
e15a <- t(e15a)
e16a <- t(e16a)
e17a <- t(e17a)
P00a <- t(P00a)
P04a <- t(P04a)
P07a <- t(P07a)
P10a <- t(P10a)

e10a <- rownames_to_column(data.frame (e10a), var = 'cells')
e11a <- rownames_to_column(data.frame (e11a), var = 'cells')
e12a <- rownames_to_column(data.frame (e12a), var = 'cells')
e13a <- rownames_to_column(data.frame (e13a), var = 'cells')
e14a <- rownames_to_column(data.frame (e14a), var = 'cells')
e15a <- rownames_to_column(data.frame (e15a), var = 'cells')
e16a <- rownames_to_column(data.frame (e16a), var = 'cells')
e17a <- rownames_to_column(data.frame (e17a), var = 'cells')
P00a <- rownames_to_column(data.frame (P00a), var = 'cells')
P04a <- rownames_to_column(data.frame (P04a), var = 'cells')
P07a <- rownames_to_column(data.frame (P07a), var = 'cells')
P10a <- rownames_to_column(data.frame (P10a), var = 'cells')

# merge data and compute correlation between auc activity scores based on indepdenent time points vs replicate A
regulonActivity_byTimePoint <- full_join(e10a, e11a, by ='cells')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, e11a, by = 'cells')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, e12a, by = 'cells')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, e13a, by = 'cells')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, e14a, by = 'cells')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, e15a, by = 'cells')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, e16a, by = 'cells')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, e17a, by = 'cells')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, P00a, by = 'cells')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, P04a, by = 'cells')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, P07a, by = 'cells')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, P10a, by = 'cells')

regulonActivity_byTimePoint[is.na(regulonActivity_byTimePoint)] <- 0

colnames(regulonActivity_byTimePoint) <- str_replace(colnames(regulonActivity_byTimePoint), '[.]', '-')
regulonActivity_byTimePoint <- column_to_rownames(regulonActivity_byTimePoint, var = 'cells')
```

```{r}
# TODO barplot for number of cells Vs number of regulons at each time point
e10a <- read.csv('../data/individual_time_points/e10A/auc_mtx.csv'); e10a <- column_to_rownames(e10a, var = 'Cell'); 
e11a <- read.csv('../data/individual_time_points/e11A/auc_mtx.csv'); e11a <- column_to_rownames(e11a, var = 'Cell'); 
e12a <- read.csv('../data/individual_time_points/e12A/auc_mtx.csv'); e12a <- column_to_rownames(e12a, var = 'Cell'); 
e13a <- read.csv('../data/individual_time_points/e13A/auc_mtx.csv'); e13a <- column_to_rownames(e13a, var = 'Cell'); 
e14a <- read.csv('../data/individual_time_points/e14A/auc_mtx.csv'); e14a <- column_to_rownames(e14a, var = 'Cell'); 
e15a <- read.csv('../data/individual_time_points/e15A/auc_mtx.csv'); e15a <- column_to_rownames(e15a, var = 'Cell'); 
e16a <- read.csv('../data/individual_time_points/e16A/auc_mtx.csv'); e16a <- column_to_rownames(e16a, var = 'Cell'); 
e17a <- read.csv('../data/individual_time_points/e17A/auc_mtx.csv'); e17a <- column_to_rownames(e17a, var = 'Cell'); 
P00a <- read.csv('../data/individual_time_points/P0OA/auc_mtx.csv'); P00a <- column_to_rownames(P00a, var = 'Cell'); 
P04a <- read.csv('../data/individual_time_points/P04A/auc_mtx.csv'); P04a <- column_to_rownames(P04a, var = 'Cell'); 
P07a <- read.csv('../data/individual_time_points/P07A/auc_mtx.csv'); P07a <- column_to_rownames(P07a, var = 'Cell'); 
P10a <- read.csv('../data/individual_time_points/P10A/auc_mtx.csv'); P10a <- column_to_rownames(P10a, var = 'Cell');

e10a_seurat <- readRDS ('../data/individual_time_points/e10A/brain.data.e10A.Rds')
e11a_seurat <- readRDS ('../data/individual_time_points/e11A/brain.data.e11A.Rds')
e12a_seurat <- readRDS ('../data/individual_time_points/e12A/brain.data.e12A.Rds')
e13a_seurat <- readRDS ('../data/individual_time_points/e13A/brain.data.e13A.Rds')
e14a_seurat <- readRDS ('../data/individual_time_points/e14A/brain.data.e14A.Rds')
e15a_seurat <- readRDS ('../data/individual_time_points/e15A/brain.data.e15A.Rds')
e16a_seurat <- readRDS ('../data/individual_time_points/e16A/brain.data.e16A.Rds')
e17a_seurat <- readRDS ('../data/individual_time_points/e17A/brain.data.e17A.Rds')
P00a_seurat <- readRDS ('../data/individual_time_points/P0OA/brain.data.P0OA.Rds')
P04a_seurat <- readRDS ('../data/individual_time_points/P04A/brain.data.P04A.Rds')
P07a_seurat <- readRDS ('../data/individual_time_points/P07A/brain.data.P07A.Rds')
P10a_seurat <- readRDS ('../data/individual_time_points/P10A/brain.data.P10A.Rds')

e10a <- sapply(split(rownames(e10a), Idents(e10a_seurat)), function(cells) rowMeans(t(e10a)[,cells])); colnames(e10a) <- paste("e10A", colnames(e10a), sep = '_')
e11a <- sapply(split(rownames(e11a), Idents(e11a_seurat)), function(cells) rowMeans(t(e11a)[,cells])); colnames(e11a) <- paste("e11A", colnames(e11a), sep = '_')
e12a <- sapply(split(rownames(e12a), Idents(e12a_seurat)), function(cells) rowMeans(t(e12a)[,cells])); colnames(e12a) <- paste("e12A", colnames(e12a), sep = '_')
e13a <- sapply(split(rownames(e13a), Idents(e13a_seurat)), function(cells) rowMeans(t(e13a)[,cells])); colnames(e13a) <- paste("e13A", colnames(e13a), sep = '_')
e14a <- sapply(split(rownames(e14a), Idents(e14a_seurat)), function(cells) rowMeans(t(e14a)[,cells])); colnames(e14a) <- paste("e14A", colnames(e14a), sep = '_')
e15a <- sapply(split(rownames(e15a), Idents(e15a_seurat)), function(cells) rowMeans(t(e15a)[,cells])); colnames(e15a) <- paste("e15A", colnames(e15a), sep = '_')
e16a <- sapply(split(rownames(e16a), Idents(e16a_seurat)), function(cells) rowMeans(t(e16a)[,cells])); colnames(e16a) <- paste("e16A", colnames(e16a), sep = '_')
e17a <- sapply(split(rownames(e17a), Idents(e17a_seurat)), function(cells) rowMeans(t(e17a)[,cells])); colnames(e17a) <- paste("e17A", colnames(e17a), sep = '_')
P00a <- sapply(split(rownames(P00a), Idents(P00a_seurat)), function(cells) rowMeans(t(P00a)[,cells])); colnames(P00a) <- paste("P00A", colnames(P00a), sep = '_')
P04a <- sapply(split(rownames(P04a), Idents(P04a_seurat)), function(cells) rowMeans(t(P04a)[,cells])); colnames(P04a) <- paste("P04A", colnames(P04a), sep = '_')
P07a <- sapply(split(rownames(P07a), Idents(P07a_seurat)), function(cells) rowMeans(t(P07a)[,cells])); colnames(P07a) <- paste("P07A", colnames(P07a), sep = '_')
P10a <- sapply(split(rownames(P10a), Idents(P10a_seurat)), function(cells) rowMeans(t(P10a)[,cells])); colnames(P10a) <- paste("P10A", colnames(P10a), sep = '_')

e10a <- tibble::rownames_to_column(data.frame (e10a), var = 'Regulons')
e11a <- tibble::rownames_to_column(data.frame (e11a), var = 'Regulons')
e12a <- tibble::rownames_to_column(data.frame (e12a), var = 'Regulons')
e13a <- tibble::rownames_to_column(data.frame (e13a), var = 'Regulons')
e14a <- tibble::rownames_to_column(data.frame (e14a), var = 'Regulons')
e15a <- tibble::rownames_to_column(data.frame (e15a), var = 'Regulons')
e16a <- tibble::rownames_to_column(data.frame (e16a), var = 'Regulons')
e17a <- tibble::rownames_to_column(data.frame (e17a), var = 'Regulons')
P00a <- tibble::rownames_to_column(data.frame (P00a), var = 'Regulons')
P04a <- tibble::rownames_to_column(data.frame (P04a), var = 'Regulons')
P07a <- tibble::rownames_to_column(data.frame (P07a), var = 'Regulons')
P10a <- tibble::rownames_to_column(data.frame (P10a), var = 'Regulons')

# join all time points keeping union of regulons, missing regulons are indicated by NA
regulonActivity_byTimePoint <- NULL; 
regulonActivity_byTimePoint <- full_join(e10a, e11a, by = 'Regulons')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, e12a, by = 'Regulons')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, e13a, by = 'Regulons')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, e14a, by = 'Regulons')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, e15a, by = 'Regulons')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, e16a, by = 'Regulons')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, e17a, by = 'Regulons')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, P00a, by = 'Regulons')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, P04a, by = 'Regulons')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, P07a, by = 'Regulons')
regulonActivity_byTimePoint <- full_join(regulonActivity_byTimePoint, P10a, by = 'Regulons')

# replace NA by zero
regulonActivity_byTimePoint[is.na (regulonActivity_byTimePoint)] <- 0 
# dim(regulonActivity_byTimePoint)
# 697 153
```

```{r}
# visualise
library (tibble)
regulonActivity_byTimePoint <- column_to_rownames(regulonActivity_byTimePoint, var = 'Regulons')
regulonActivity_byTimePoint_Scaled <- na.omit(t(scale(t(regulonActivity_byTimePoint), center = T, scale=T)))

# heatmap annotation 
annotation <- sapply (strsplit (colnames(regulonActivity_byTimePoint), "_"), function (x) paste (x[1]))
annotation <- data.frame (annotation)
rownames(annotation) <- colnames(regulonActivity_byTimePoint)
cell_type <- sapply (strsplit (rownames(annotation), "_"), function (x) paste (x[2]))
annotation <- cbind (annotation, cell_type); annotation <- annotation[-1, ]
colnames(annotation) = c('time point', 'seurat cluster')

pdf ('../plots/brain_data_A_time_points.pdf', width  = 10, height = 18)
pheatmap::pheatmap(regulonActivity_byTimePoint_Scaled, fontsize_row=2, fontsize_col = 4, color=colorRampPalette(c("blue","white","red"))(100), breaks=seq(-3, 3, length.out = 100), annotation= annotation, treeheight_row=10, treeheight_col=10, border_color=NA, clustering_method = 'ward.D2')
dev.off()
```


```{r}
# regulon activity by time point matched to cellassign annotation per time point

```


```{r}
# extract time point specific regulons
regulonActivity_byTimePoint <- data.frame (regulonActivity_byTimePoint)

P07A_8 <- regulonActivity_byTimePoint[regulonActivity_byTimePoint$P07A_8 > quantile(regulonActivity_byTimePoint$P07A_8) [4], ]; P07A_8 <- rownames(P07A_8)

e10=NULL; e10=union(e10A_0, e10A_1); e10=union(e10, e10A_2); e10=union(e10,e10A_3); e10=union(e10,e10A_4); e10=union(e10,e10A_5); e10=union(e10,e10A_6); e10=union(e10,e10A_7)

e11=NULL; e11=union(e11A_0, e11A_1); e11=union(e11, e11A_2); e11=union(e11,e11A_3); e11=union(e11,e11A_4); e11=union(e11,e11A_5); e11=union(e11,e11A_6); e11=union(e11,e11A_7); e11=union(e11,e11A_8); e11=union(e11,e11A_9)

e12=NULL; e12=union(e12A_0, e12A_1); e12=union(e12, e12A_2); e12=union(e12,e12A_3); e12=union(e12,e12A_4); e12=union(e12,e12A_5); e12=union(e12,e12A_6); e12=union(e12,e12A_7); e12=union(e12,e12A_8); e12=union(e12,e12A_9); e12=union(e12,e12A_10); e12=union(e12,e12A_11); e12=union(e12,e12A_12);e12=union(e12,e12A_13); e12=union(e12,e12A_14); 

e13=NULL; e13=union(e13A_0, e13A_1); e13=union(e13, e13A_2); e13=union(e13,e13A_3); e13=union(e13,e13A_4); e13=union(e13,e13A_5); e13=union(e13,e13A_6); e13=union(e13,e13A_7); e13=union(e13,e13A_8); e13=union(e13,e13A_9); e13=union(e13,e13A_10); e13=union(e13,e13A_11); e13=union(e13,e13A_12);e13=union(e13,e13A_13); e13=union(e13,e13A_14); 

e14=NULL; e14=union(e14A_0, e14A_1); e14=union(e14, e14A_2); e14=union(e14,e14A_3); e14=union(e14,e14A_4); e14=union(e14,e14A_5); e14=union(e14,e14A_6); e14=union(e14,e14A_7); e14=union(e14,e14A_8); e14=union(e14,e14A_9); e14=union(e14,e14A_10); e14=union(e14,e14A_11); e14=union(e14,e14A_12);e14=union(e14,e14A_13); e14=union(e14,e14A_14); e14=union(e14,e14A_15); 

e15=NULL; e15=union(e15A_0, e15A_1); e15=union(e15, e15A_2); e15=union(e15,e15A_3); e15=union(e15,e15A_4); e15=union(e15,e15A_5); e15=union(e15,e15A_6); e15=union(e15,e15A_7); e15=union(e15,e15A_8); e15=union(e15,e15A_9); e15=union(e15,e15A_10); e15=union(e15,e15A_11); e15=union(e15,e15A_12); 

e16=NULL; e16=union(e16A_0, e16A_1); e16=union(e16, e16A_2); e16=union(e16,e16A_3); e16=union(e16,e16A_4); e16=union(e16,e16A_5); e16=union(e16,e16A_6); e16=union(e16,e16A_7); e16=union(e16,e16A_8); e16=union(e16,e16A_9); e16=union(e16,e16A_10); 

e17=NULL; e17=union(e17A_0, e17A_1); e17=union(e17, e17A_2); e17=union(e17,e17A_3); e17=union(e17,e17A_4); e17=union(e17,e17A_5); e17=union(e17,e17A_6); e17=union(e17,e17A_7); e17=union(e17,e17A_8); e17=union(e17,e17A_9); e17=union(e17,e17A_10); e17=union(e17,e17A_11); e17=union(e17,e17A_12); e17=union(e17,e17A_13);e17=union(e17,e17A_14);

P00=NULL; P00=union(P00A_0, P00A_1); e17=union(P00, P00A_2); P00=union(P00,P00A_3); P00=union(P00,P00A_4); P00=union(P00,P00A_5); P00=union(P00,P00A_6); P00=union(P00,P00A_7); P00=union(P00,P00A_8); P00=union(P00,P00A_9); P00=union(P00,P00A_10); P00=union(P00,P00A_11); P00=union(P00,P00A_12);P00=union(P00,P00A_13);

P04=NULL; P04=union(P04A_0, P04A_1); P04=union(P04, P04A_2); P04=union(P04,P04A_3); P04=union(P04,P04A_4); P04=union(P04,P04A_5); P04=union(P04,P04A_6); P04=union(P04,P04A_7); P04=union(P04,P04A_8); P04=union(P04,P04A_9); P04=union(P04,P04A_10); P04=union(P04,P04A_11); P04=union(P04,P04A_12);

P07=NULL; P07=union(P07A_0, P07A_1); P07=union(P07, P07A_2); P07=union(P07,P07A_3); P07=union(P07,P07A_4); P07=union(P07,P07A_5); P07=union(P07,P07A_6); P07=union(P07,P07A_7); P07=union(P07,P07A_8); 

P10=NULL; P10=union(P10A_0, P10A_1); P10=union(P10, P10A_2); P10=union(P10,P10A_3); P10=union(P10,P10A_4); P10=union(P10,P10A_5); P10=union(P10,P10A_6); P10=union(P10,P10A_7); P10=union(P10,P10A_8); P10=union(P10,P10A_9); P10=union(P10,P10A_10); P10=union(P10,P10A_11); P10=union(P10,P10A_12); 


listInput=NULL; listInput <- list(e10=e10, e11=e11, e12=e12, e13=e13, e14=e14, e15=e15, e16=e16, e17=e17, P00=P00, P04=P04, P07=P07, P10=P10)
pdf ('../plots/regulons_byTimePoint.pdf', width = 10, height = 10)
upset(fromList(listInput), nsets = 12, order.by = "freq", point.size = 2.5, number.angles = 30, mainbar.y.label = 'regulons per time point')
dev.off()
```

```{r}
# assess correlation between regulons common across all timepoints, cell types and clusters
common_timepoint <- intersect(e10, e11); common_timepoint <- intersect(common_timepoint, e12); common_timepoint <- intersect(common_timepoint, e13); common_timepoint <- intersect(common_timepoint, e14); common_timepoint <- intersect(common_timepoint, e15); common_timepoint <- intersect(common_timepoint, e16); common_timepoint <- intersect(common_timepoint, e17); common_timepoint <- intersect(common_timepoint, P00); common_timepoint <- intersect(common_timepoint, P04); common_timepoint <- intersect(common_timepoint, P07); common_timepoint <- intersect(common_timepoint, P10);

common_cluster <- intersect(x0, x1); common_cluster <- intersect(common_cluster, x2); common_cluster <- intersect(common_cluster, x3); common_cluster <- intersect(common_cluster, x4); common_cluster <- intersect(common_cluster, x5); common_cluster <- intersect(common_cluster, x6); common_cluster <- intersect(common_cluster, x7); common_cluster <- intersect(common_cluster, x8); common_cluster <- intersect(common_cluster, x9); common_cluster <- intersect(common_cluster, x10); common_cluster <- intersect(common_cluster, x11); common_cluster <- intersect(common_cluster, x12); common_cluster <- intersect(common_cluster, x13); common_cluster <- intersect(common_cluster, x14); common_cluster <- intersect(common_cluster, x15); common_cluster <- intersect(common_cluster, x16); common_cluster <- intersect(common_cluster, x17); common_cluster <- intersect(common_cluster, x18); common_cluster <- intersect(common_cluster, x19); common_cluster <- intersect(common_cluster, x20); common_cluster <- intersect(common_cluster, x21); common_cluster <- intersect(common_cluster, x22); common_cluster <- intersect(common_cluster, x23); common_cluster <- intersect(common_cluster, x24); 

common_cell_type <- intersect(Astrocyte.Bergmann.glia.prec, Astrocytes.Bergmann.glia); common_cell_type <- intersect(common_cell_type, Brainstem.prog); common_cell_type <- intersect(common_cell_type, Diff.GABA.interneu); common_cell_type <- intersect(common_cell_type, Diff.granule.c.); common_cell_type <- intersect(common_cell_type,Diff.Purkinje.c.); common_cell_type <- intersect(common_cell_type, Embryonic.GCPs); common_cell_type <- intersect(common_cell_type, Endothelial.c.); common_cell_type <- intersect(common_cell_type, Excitatory.cerebellar.nuclei.neu); common_cell_type <- intersect(common_cell_type,GABA.interneu); common_cell_type <- intersect(common_cell_type,GABA.interneuron.prec ); common_cell_type <- intersect(common_cell_type, Gliogenic.prog); common_cell_type <- intersect(common_cell_type,Glutamatergic.neu ); common_cell_type <- intersect(common_cell_type, Granule.c.); common_cell_type <- intersect(common_cell_type, Meninges); common_cell_type <- intersect(common_cell_type,Mesenchymal.stem.c. ); common_cell_type <- intersect(common_cell_type, Microglia); common_cell_type <- intersect(common_cell_type, Myelinating.oligodendrocytes); common_cell_type <- intersect(common_cell_type,Neural.stem.c. ); common_cell_type <- intersect(common_cell_type,Oligodendrocyte.precursor.c. ); common_cell_type <- intersect(common_cell_type,Pericytes );common_cell_type <- intersect(common_cell_type, Post.GCPs.1); common_cell_type <- intersect(common_cell_type, Post.GCPs.2); common_cell_type <- intersect(common_cell_type,Post.gliogenic.prog ); common_cell_type <- intersect(common_cell_type, Post.glutamatergic.neu); common_cell_type <- intersect(common_cell_type,Proliferating.VZ.prog ); common_cell_type <- intersect(common_cell_type, Purkinje.c.); common_cell_type <- intersect(common_cell_type,Red.blood.c. ); common_cell_type <- intersect(common_cell_type,Roof.plate.like.stem.c. ); common_cell_type <- intersect(common_cell_type,UniBC.and.GCP.progenitor ); common_cell_type <- intersect(common_cell_type, Unipolar.brush.c.); common_cell_type <- intersect(common_cell_type, Upper.rhombic.lip.prog); common_cell_type <- intersect(common_cell_type, VZ.prog); 


write.table (common_cell_type, file = 'Documents/GRNs/data/common_regulons_cell_types.txt', sep = '\t', quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table (common_timepoint, file = 'Documents/GRNs/data/common_regulons_TimePoint.txt', sep = '\t', quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table (common_cluster, file = 'Documents/GRNs/data/common_regulons_cluster.txt', sep = '\t', quote = FALSE, row.names = FALSE, col.names = FALSE)
```

```{r}
# for each of the 40+ regulons (cell type, cluster, time point) 
# extract their regulon activity from the regulonAUC matrix from the two independent experimental setups and assess their correlation across the two setups
dat_replicate_a <- regulonAUC
dat_ind_time_points <- regulonActivity_byTimePoint

common_cells <- intersect(rownames(dat_replicate_a), colnames(dat_ind_time_points))

# compute correlation based on the common regulons across cell types, time points and clusters
dat_replicate_a <- dat_replicate_a[common_cells, colnames(dat_replicate_a) %in% common_cluster]; dat_replicate_a <- t(dat_replicate_a); dat_replicate_a [is.na(dat_replicate_a)] <- 0
dat_ind_time_points <- dat_ind_time_points[rownames(dat_ind_time_points) %in% common_cluster, common_cells]; dat_ind_time_points[is.na(dat_ind_time_points)] <- 0

# spearman
cor.test (as.matrix(dat_replicate_a), as.matrix(dat_ind_time_points), method = 'spearman')
```
```{r}
# generate a scatter plot for visualising the corrleation 
# regulons
df1 <- reshape2::melt (dat_replicate_a)
df2 <- reshape2::melt (as.matrix (dat_ind_time_points))

colnames(df1) = c('regulons', 'cells', 'activity_replicate_A')
colnames(df2) = c('regulons', 'cells', 'activity_ind_time_points')
dat = NULL; dat <- cbind(df1, df2$activity_ind_time_points); colnames(dat)[4] = c('activity_ind_time_points')

subset_1 <- sample(x = dat$cells, size = 1000)
dat_subset_1 <- dat[dat$cells %in% subset_1, ]


pdf ('~/Documents/GRNs/plots/scatter_plot_repA_vs_ind_cluster.pdf', width = 20, height = 15)
p = ggplot(dat_subset_1, aes(x = activity_replicate_A, y = activity_ind_time_points)) +
  geom_point (shape = 1) + 
  scale_colour_hue (l=50) + 
  #geom_smooth()
  geom_smooth (method = "lm",  alpha = 0.05, se = TRUE, fullrange = FALSE, position = "identity", na.rm = FALSE)
#p + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0))
p
dev.off()
```

```{r}
# compute incidence and percentage relative to AUC activity scores
Reg <- incidMat   #TF x genes #incidMat
R_comb <- combn(rownames(Reg), m=2)  #Create pairwise combinations

# Create required dataframe 
Reg1 = Reg2  = nR1_genes = nR2_genes = nR1_R2_genes = R1_R2_genes = NULL;
 
for (comb in 1:ncol(R_comb)) {
  #two_genes <- print(as.character(gene_comb2[,combo]))
 
  two_R <- as.character(R_comb[,comb])
  R1 <- data.frame(Reg[which(rownames(Reg) == two_R[1]),])
  R2 <- data.frame(Reg[which(rownames(Reg) == two_R[2]),])
  R1_2 <- cbind(R1, R2)
  colnames(R1_2) <- c("R1", "R2")
  nR1_2 <- length(which(R1_2[,1] > 0 & R1_2[,2] > 0))
  R1R2_genes <- rownames(R1_2[which(R1_2[,1] > 0 & R1_2[,2] > 0),])
  R1R2_genes <- paste(R1R2_genes,collapse=",")
  #common_Regs <- paste(cat(rownames(samples1_2[which(samples1_2[,1] > 0 & samples1_2[,2] > 0),]), sep = “,”))
  Reg1 = c(Reg1, two_R[1])
  Reg2 = c(Reg2, two_R[2])
  nR1_R2_genes = c(nR1_R2_genes, nR1_2)
  nR1_genes = c(nR1_genes, sum(R1_2[,1]))
  nR2_genes = c(nR2_genes, sum(R1_2[,2]))
 R1_R2_genes = c(R1_R2_genes, R1R2_genes[1])
 }
 Regulon_comb <- data.frame(cbind(Reg1 ,Reg2 ,nR1_R2_genes, nR1_genes , nR2_genes ,R1_R2_genes))
 Regulon_comb$R1_R2_genes <- as.character(Regulon_comb$R1_R2_genes)
 Regulon_comb$R1_R2_genes[Regulon_comb$R1_R2_genes == ""] <- "NA"
 saveRDS(Regulon_comb, file = '../data/Regulon_comb_replicate_A.Rds')

 Regulon_comb <- readRDS('../data/Regulon_comb_replicate_A.Rds')
 
## Calculate percentage and incidence from the incidence matrix
# Percentage -> proportion of overlapping genes
# % = nR1_R2_genes/(nR1_genes + nR2_genes) - nR1_R2_genes

# Incidence -> proportion of genes regulated by the TF pair out of total
# incidence = (nR1_genes + nR2_genes - nR1_R2_genes)/number_of_genes_in_regulons

tab <- Regulon_comb
tab$R1_R2_genes <- NULL
#tab <- tab[subset(rownames(tab), tab$nR1_R2_genes != 0),]  #Remove TFs that do not have overlapping genes
# I commented this line because we need to look at regulons that do not have overlapping genes but have correlated activity scores
#Reg <- readRDS("int/2.6_regulons_asIncidMat.Rds")
tab <- tab %>% 
cbind(percentage =(round(  as.numeric(as.character(tab$nR1_R2_genes))   /  ((as.numeric(as.character(tab$nR1_genes))+as.numeric(as.character(tab$nR2_genes))) - as.numeric(as.character(tab$nR1_R2_genes)))  ,3))*100) %>% 
cbind(incidence = round(((as.numeric(as.character(tab$nR1_genes))+as.numeric(as.character(tab$nR2_genes))) - as.numeric(as.character(tab$nR1_R2_genes))) /ncol(Reg),3))


tab <- tab %>% separate(Reg2, c("Regulon2","suffix2"), sep = "_")
tab <- tab %>% separate(Reg1, c("Regulon1","suffix1"), sep = "_")
tab <- tab[subset(rownames(tab), tab$Regulon1 != tab$Regulon2),]


#for (i in nrow(tab)){
#if(tab[i,]$suffix1 == "extended"){
reg1 <- paste(tab$Regulon1, tab$suffix1, sep = "_")
#}}
#tab[,1] <- reg1

#for (i in nrow(tab)){
#if(tab[i,]$suffix == "extended"){
reg2 <- paste(tab$Regulon2, tab$suffix2, sep = "_")
#}}
#tab[,3] <- reg2

#Remove NA
reg1 <- gsub("_NA","",reg1)
reg2 <- gsub("_NA","",reg2)

#Repopulate the dataframe
tab$Regulon1 <- reg1
tab$Regulon2 <- reg2

tab$suffix1 <- NULL
tab$suffix2 <- NULL

# commented this line because we need to look at correlated regulons by activity scores that might have non-overlapping genes
#Keep TF pairs regulating more than 15% of overlapping genes
#tab1 <- tab[subset(rownames(tab),tab$percentage > 20),]
```

```{r}
# Calculate correlation between regulons based on activity scores
# library(AUCell)
#AUC <- readRDS("int/3.4_regulonAUC.Rds") # Regulons * cells
#AUC <- getAUC(AUC)
AUC <- regulonAUC
AUC <- cor(AUC, method="spearman") # potentially consider MI
AUC <- data.frame(row=rownames(AUC)[row(AUC)], col=colnames(AUC)[col(AUC)], corr=c(AUC))

AUC <- AUC %>% separate(row, c("Reg1","G1"), sep=" ")
AUC <- AUC %>% separate(col, c("Reg2","G2"), sep=" ")

colnames(AUC) [1] <- c('Regulon1')
colnames(AUC) [3] <- c('Regulon2')

AUC$G1 <- NULL
AUC$G2 <- NULL

# check correlation values distribution
ggplot(AUC, aes(x = corr)) + geom_density()
ggplot(AUC, aes(x = corr)) + geom_histogram(binwidth = .1)

quantile(AUC$corr)
#          0%          25%          50%          75%         100% 
#-0.740948674 -0.062414723  0.001366811  0.080888892  1.000000000 

# filter by corr based on activity score
pos <- AUC[AUC$corr >= 0.7, ]
neg <- AUC[AUC$corr <= -0.6, ]
dim(pos)
# 412    3
dim(neg)
# 152   3
AUC_sig <- rbind (pos, neg)
```

```{r}
# dot plot for incidence and % overlap
# append incidence and percentage to AUC corr values
dat <- rbind(pos, neg)
rownames(dat) <- paste(dat$Regulon2, dat$Regulon1, sep = "-")  
rownames(tab) <- paste(tab$Regulon1, tab$Regulon2, sep = "-")
dat <- tibble ::rownames_to_column (dat, var = 'ID')
tab <- tibble :: rownames_to_column (tab, var = 'ID')
# join by ID
dat <- inner_join(tab, dat, by = 'ID')
#valid_rows <- rownames(tab)
#AUC <- AUC[valid_rows,]  #Get correlation values only for required TF pairs
# tab$corr <- AUC$corr  #Add correlation values to the dataframe
# fct_rev to get lower triangular plot
library (forcats)
dat$Regulon2.y = forcats::fct_rev(factor(dat$Regulon2.y))
# plot subset of dat

# draw the dotplot
dotplot <- ggplot2::ggplot(data = dat, mapping =  ggplot2::aes(x = Regulon1.y, y = Regulon2.y)) + 
  #ggplot2::geom_point(mapping = ggplot2::aes(color = corr, size = ifelse(percentage==0.00, NA, percentage))) + 
  ggplot2::geom_point(mapping = ggplot2::aes(color = corr, size = percentage)) + 
  ggplot2::theme(axis.text.x.bottom = ggplot2::element_text(angle = 90, vjust = 0, hjust = 1, size = 4)) +
  ggplot2::theme(axis.text.y = ggplot2::element_text(size = 4)) +
  ggplot2::ggtitle("correlated regulons") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::scale_x_discrete(position = "bottom") + ggplot2::labs(size = 'percentage of overalapping genes', color = 'correlation between regulons activity scores')

pdf("../plots/correlated_regulons_across_replicate_A_dotplot.pdf", height = 10, width = 12)
plot(dotplot)
dev.off()
```

```{r}
# read markers list
markers <- read.csv('../data/mouse_brain_marker_genes.csv')
gpd_genes <- read.table('../data/GPD_genes_mouse.txt'); gpd_genes = gpd_genes$V2

```


```{r}
# plot the network
sub = NULL; sub = dat
REG1 <- data.frame(Regulon1 = sub$Regulon1.x, n_genes = sub$nR1_genes)
REG1 <- unique(REG1)
REG2 <- data.frame(Regulon1 = sub$Regulon2.x, n_genes = sub$nR2_genes)
REG2 <- unique(REG2)
nodes <- unique(rbind(REG1,REG2))  #Assign TF as nodes
rownames(nodes) <- NULL
names(nodes) <- c("Regulons","n_genes")
links <- data.frame(Regulon1 = sub$Regulon1.x, Regulon2 = sub$Regulon2.x, percentage = sub$percentage, corr = sub$corr) #Info on nodes and edges
net <- graph.data.frame(d = links, vertices = nodes, directed = F)
centrality = eigen_centrality(net)$vector  #Measure centrality
centrality <- data.frame(centrality)
#leastcentral <- subset(rownames(centrality), centrality$centrality < (fivenum(centrality$centrality)[3]))  
# remove nodes with less than 25% of centrality values
leastcentral <- subset(rownames(centrality), centrality$centrality < (quantile(centrality$centrality)[2]))
net <- delete_vertices(net, leastcentral) #Remove nodes with least centrality

#Graph attributes
# nodes
colrs <- c("gray50", "tomato", "gold")
#Compute node degrees (#links) and use that to set node size:
#deg <- degree(net, mode="all")
#V(net)$size <- deg/3
V(net)$size <- as.numeric(V(net)$n_genes)*0.01
#V(net)$label.color <- "black"
#E(net)$width <-  rescale(E(net)$corr, to = c(0.5,2.5))
#E(net)$width <-  rescale(E(net)$corr, to = c(0,2))
#E(net)$edge.color <- c("slategrey", "dark red")[(E(net)$corr < 0)+1]
#E(net)$edge.color <- c("slategrey", "dark red")[(E(net)$corr < 0)*-1]
#col1 <- adjustcolor( "blue", alpha.f = 0.3) # +ve correlation
#col2 <- adjustcolor( "red", alpha.f = 0.3)  # -ve correlation
#E(net)$edge.color <- c(col1, col2)[(E(net)$corr < 0)]
#E(net)$edge.color <- c(col1, col2)
# edges
#E(net)$edge.width <- abs(E(net)$corr)*8
E(net)$edge.width <- abs(E(net)$percentage)*2
E(net)$color <- ifelse(E(net)$corr > 0, "blue","red")

#Plot
pdf("../plots/corrleated_regulons_net_replicate_A.pdf")
plot(net,vertex.label.cex = 0.5,vertex.color = "orange", edge.color = E(net)$edge.color,edge.width = E(net)$width, vertex.size = V(net)$size, vertex.label.font = 2, vertex.label.dist = 0.8, layout = layout_with_graphopt,main = 'base network')


# louvain 
# https://igraph.org/r/doc/cluster_louvain.html
communities <- cluster_louvain (net, weights = E(net)$edge.width)
membership(communities); e10A_communities_membership = membership(communities)
modularity(communities)
plot(communities, net, layout=layout_with_graphopt, vertex.label.dist=0.5, vertex.size=V(net)$size, vertex.label.cex = 0.5, edge.color = E(net)$edge.color, edge.width = E(net)$edge.width/8, main = 'louvain clusters')

# leiden
adjacency_matrix <- igraph::as_adjacency_matrix(net, edges = TRUE)
# run the leiden algorithm on the adjacency matrix
partition <- leiden(adjacency_matrix, resolution_parameter = 1, node_sizes = V(net)$size, weights = NULL)
table(partition)
# visualise
node.cols <- brewer.pal(max(c(4, partition)),"Set3")[partition]
#node.cols <- rainbow(5, alpha=.5)
#node.cols <- brewer.pal(4, "Set3")
plot(net, layout=layout_with_graphopt, vertex.color = node.cols, edge.color = E(net)$edge.color, vertex.label.dist=1, vertex.size=V(net)$size, vertex.label.cex = 0.5, edge.width = E(net)$edge.width/8, main = 'leiden clusters')

dev.off()

saveRDS(net, file = '../data/correlated_regulons_replicate_A.Rds')
```

```{r}
# https://cran.r-project.org/web/packages/leiden/vignettes/run_leiden.html
# cluster the networks
# leiden
adjacency_matrix <- igraph::as_adjacency_matrix(net, edges = TRUE)
# run the leiden algorithm on the adjacency matrix
partition <- leiden(adjacency_matrix, resolution_parameter = 1, node_sizes = V(net)$size, weights = NULL)
table(partition)

# visualise
node.cols <- brewer.pal(max(c(4, partition)),"Set3")[partition]
#node.cols <- rainbow(5, alpha=.5)
#node.cols <- brewer.pal(4, "Set3")
plot(net, vertex.color = node.cols, edge.color = E(net)$edge.color, , vertex.label.cex = 0.5)
plot(net, layout=layout_with_fr, vertex.color = node.cols, edge.color = E(net)$edge.color, vertex.label.dist=1, vertex.size=V(net)$size, vertex.label.cex = 0.5, edge.width = E(net)$edge.width/8)

plot(net, layout=layout_with_drl, vertex.color = node.cols, edge.color = E(net)$edge.color, vertex.label.dist=1, vertex.size=V(net)$size, vertex.label.cex = 0.5, edge.width = E(net)$edge.width/8)

plot(net, layout=layout_with_kk, vertex.color = node.cols, edge.color = E(net)$edge.color, vertex.label.dist=1, vertex.size=V(net)$size, vertex.label.cex = 0.5, edge.width = E(net)$edge.width/8)

plot(net, layout=layout_with_mds, vertex.color = node.cols, edge.color = E(net)$edge.color, vertex.label.dist=1, vertex.size=V(net)$size, vertex.label.cex = 0.5, edge.width = E(net)$edge.width/8)

plot(net, layout=layout_with_lgl, vertex.color = node.cols, edge.color = E(net)$edge.color, vertex.label.dist=1, vertex.size=V(net)$size, vertex.label.cex = 0.5, edge.width = E(net)$edge.width/8)

plot(net, layout=layout_with_graphopt, vertex.color = node.cols, edge.color = E(net)$edge.color, vertex.label.dist=1, vertex.size=V(net)$size, vertex.label.cex = 0.5, edge.width = E(net)$edge.width/8)
```

```{r}
# overlapping nodes 
# leiden clusters
par(mfrow=c(1, 3))
g <- net
plot(g,layout=layout_with_fr,vertex.color = node.cols, edge.color = E(net)$edge.color, vertex.label.dist=1, vertex.size=V(net)$size, edge.width = E(net)$edge.width/8, vertex.label.cex = 0.5)
mtext("layout_with_fr", side=1)
e <- get.edgelist(g); e <- get.edgelist(g,names=FALSE)
l <- qgraph.layout.fruchtermanreingold(e,vcount=vcount(g))
plot(g,layout=layout_with_fr,vertex.color = node.cols, edge.color = E(net)$edge.color, vertex.label.dist=1, vertex.size=V(net)$size, edge.width = E(net)$edge.width/8, vertex.label.cex = 0.5)
mtext("qgraph.layout.fruchtermanreingold default", side=1)

l <- qgraph.layout.fruchtermanreingold(e,vcount=vcount(g),
      area=8*(vcount(g)^2),repulse.rad=(vcount(g)^3.1))
plot(g,layout=layout_with_fr,vertex.color = node.cols, edge.color = E(net)$edge.color, vertex.label.dist=1, vertex.size=V(net)$size, edge.width = E(net)$edge.width/8, vertex.label.cex = 0.5)
mtext("qgraph.layout.fruchtermanreingold modified", side=1)

```

```{r}
# community detection based on label propagation
clp <- cluster_label_prop(net)
class(clp)
# Community detection returns an object of class "communities" # which igraph knows how to plot:
plot(clp, net)
# We can also plot the communities without relying on their built-in plot:
V(net)$community <- clp$membership
colrs <- adjustcolor( c("gray50", "tomato", "gold", "yellowgreen"), alpha=.6) 
plot(net, vertex.color=colrs[V(net)$community], edge.width = E(net)$edge.width/8, edge.color = E(net)$edge.color, vertex.size = V(net)$size, layout = layout_with_kk)
```


```{r}
# louvain 
# https://igraph.org/r/doc/cluster_louvain.html
communities <- cluster_louvain (net, weights = E(net)$edge.width)
membership(communities)
modularity(communities)
plot(communities, net)
plot(communities, net, layout=layout_with_fr, vertex.label.dist=1, vertex.size=V(net)$size, vertex.label.cex = 0.5, edge.color = E(net)$edge.color, edge.width = E(net)$edge.width/8, vertex.color = node.cols)
plot(communities, net, layout=layout_with_drl, vertex.label.dist=1, vertex.size=V(net)$size, vertex.label.cex = 0.5, edge.color = E(net)$edge.color, edge.width = E(net)$edge.width/8)
plot(communities, net, layout=layout_with_kk, vertex.label.dist=1, vertex.size=V(net)$size, vertex.label.cex = 0.5, edge.color = E(net)$edge.color, edge.width = E(net)$edge.width/8)
plot(communities, net, layout=layout_with_mds, vertex.label.dist=1, vertex.size=V(net)$size, vertex.label.cex = 0.5, edge.color = E(net)$edge.color, edge.width = E(net)$edge.width/8)
plot(communities, net, layout=layout_with_lgl, vertex.label.dist=1, vertex.size=V(net)$size, vertex.label.cex = 0.5, edge.color = E(net)$edge.color, edge.width = E(net)$edge.width/8)
plot(communities, net, layout=layout_with_graphopt, vertex.label.dist=0.5, vertex.size=V(net)$size, vertex.label.cex = 0.5, edge.color = E(net)$edge.color, edge.width = E(net)$edge.width/8)

```


```{r}
# focus on regulons whose target overlap is minimal but are highly correlated according to the activity scores
zero_overlap <- tab[tab$nR1_R2_genes == 0, ] # 62675     8
dat <- AUC_sig[AUC_sig$Regulon1 %in% zero_overlap$Regulon1 | AUC_sig$Regulon1 %in% zero_overlap$Regulon2 | AUC_sig$Regulon2 %in% zero_overlap$Regulon1 | AUC_sig$Regulon2 %in% zero_overlap$Regulon2, ]

# removed duplicates and non-unique regulon-regulon links
dat <- read.delim ('../data/correlated_regulons_with_zero_overlapping_targets.txt')
int_regulon_AUC <- regulonAUC[,colnames(regulonAUC) %in% dat$Regulon1 | colnames(regulonAUC) %in% dat$Regulon2]

```


```{r}
# correlated non overlapping regulons by Cell type
# plot by timepoint, cluster and cell type
sub = NULL; sub = regulonActivity_byCellType
common_1 <- intersect(rownames(sub), dat$Regulon1.x)
common_2 <- intersect(rownames(sub), dat$Regulon2.x)
common <- union (common_1, common_2)
sub <- sub[common, ]

pdf ('../plots/corr_no_overlap_regulons_byCellType.pdf', width  = 8, height = 15)
sub_Scaled <- t(scale(t(sub), center = T, scale=T))
pheatmap::pheatmap(sub_Scaled, #fontsize_row=3, 
                   color=colorRampPalette(c("blue","white","red"))(100), breaks=seq(-3, 3, length.out = 100), fontsize_row = 5, 
                   treeheight_row=10, treeheight_col=10, border_color=NA)
dev.off()

# NMF
seed= 123456
# run at multiple ranks and choose the one at which the cophenetic value starts to decrease
# Estimation of the rank: Consensus matrices computed from 10 runs for each value of r
estim.r <- nmf (sub, 2:10, nrun = 10, seed = seed)
pdf ('../plots/RegulonActivity_byCellType_nmf_single_method_over_range_of_ranks.pdf', width = 20, height = 18)
plot(estim.r)
#consensusmap (estim.r, annCol = annotation)
consensusmap (estim.r)
dev.off()

# randomize the data and recompute the rank
# shuffle the original data
V.random <- randomize (sub)
# estimate quality measures from the shuffled data using default nmf algorithm
estim.r.random <- nmf (V.random, 4, nrun = 10, seed = 123456)
# plot measures on the same graph
#pdf ('RegulonActivity_byTimePoint_nmf_single_method_over_range_of_ranks_randomized.pdf', width= 20, height = 18)
plot (estim.r, estim.r.random)
#dev.off()

# nmf results
res <- nmf(sub, 2, seed = seed)

# visualise nmf results
#pdf ('RegulonActivity_byTimePoint_nmf_coefficient_matrix.pdf')
coefmap(res) 
basismap (res, annRow=list(basis=':basis'))
#dev.off()
# retrieve the fitted model
fit(res)
#<Object of class:NMFstd>
#features: 790 
#basis/rank: 8 
#samples: 152
# quality measures
summary (res)

# nmf matrices are sparse, metagenes can be characterized by a small group of genes
# those are determined based on their relative contribution to each metagene
feature_scores <- featureScore(res, method = 'kim')
summary (feature_scores)

# plot distribution of regulons feature scores
df <- data.frame (feature_scores)
ggplot (df, aes(x = feature_scores)) + 
  geom_histogram(binwidth=.1) + 
  geom_vline(xintercept = median (feature_scores, na.rm = T), color = 'red', linetype = 'dashed', size = 1)

# compute the scores and characterise each metagenes
# extract top 5 for each basis
#s <- extractFeatures(res, 5L)

# extract features that have a relative basis contribution above a threshold
s <- extractFeatures(res, 0.25, nodups = TRUE)
str(s)

# check identity of each rank
type_1 <- feature_scores[s[[1]]]
type_2 <- feature_scores[s[[2]]]
#type_3 <- feature_scores[s[[3]]]
#type_4 <- feature_scores[s[[4]]]

type1_dat <- sub_Scaled[rownames(sub_Scaled) %in% names(type_1), ]
type2_dat <- sub_Scaled[rownames(sub_Scaled) %in% names(type_2), ]
#type3_dat <- sub_Scaled[rownames(sub_Scaled) %in% names(type_3), ]
#type4_dat <- sub_Scaled[rownames(sub_Scaled) %in% names(type_4), ]
pdf ('../plots/nmf_corr_no_overlap_regulons_byCellTypes.pdf')
pheatmap::pheatmap(type1_dat, fontsize_row=5, fontsize_col = 4, color=colorRampPalette(c("blue","white","red"))(100), breaks=seq(-3, 3, length.out = 100), treeheight_row=10, treeheight_col=10, border_color=NA)
pheatmap::pheatmap(type2_dat, fontsize_row=5, fontsize_col = 4, color=colorRampPalette(c("blue","white","red"))(100), breaks=seq(-3, 3, length.out = 100), treeheight_row=10, treeheight_col=10, border_color=NA)
pheatmap::pheatmap(type3_dat, fontsize_row=5, fontsize_col = 4, color=colorRampPalette(c("blue","white","red"))(100), breaks=seq(-3, 3, length.out = 100), treeheight_row=10, treeheight_col=10, border_color=NA)
pheatmap::pheatmap(type4_dat, fontsize_row=5, fontsize_col = 4, color=colorRampPalette(c("blue","white","red"))(100), breaks=seq(-3, 3, length.out = 100), treeheight_row=10, treeheight_col=10, border_color=NA)
dev.off()
```

```{r}
# correlated non overlapping regulons by Cell type
# plot by timepoint, cluster and cell type
sub = NULL; sub = regulonActivity_byTimePoint
common_1 <- intersect(rownames(sub), dat$Regulon1)
common_2 <- intersect(rownames(sub), dat$Regulon2)
common <- union (common_1, common_2)
sub <- sub[common, ]

pdf ('../plots/corr_no_overlap_regulons_byTimePoint.pdf', width  = 20, height = 10)
sub_Scaled <- t(scale(t(sub), center = T, scale=T))
pheatmap::pheatmap(sub_Scaled, #fontsize_row=3, 
                   color=colorRampPalette(c("blue","white","red"))(100), breaks=seq(-3, 3, length.out = 100), fontsize_row = 5, 
                   treeheight_row=10, treeheight_col=10, border_color=NA)
dev.off()

# NMF
seed= 123456
# run at multiple ranks and choose the one at which the cophenetic value starts to decrease
# Estimation of the rank: Consensus matrices computed from 10 runs for each value of r
estim.r <- nmf (sub, 2:10, nrun = 10, seed = seed)
#pdf ('RegulonActivity_byTimePoint_nmf_single_method_over_range_of_ranks.pdf', width = 20, height = 18)
plot(estim.r)
#consensusmap (estim.r, annCol = annotation)
#dev.off()

# randomize the data and recompute the rank
# shuffle the original data
V.random <- randomize (sub)
# estimate quality measures from the shuffled data using default nmf algorithm
estim.r.random <- nmf (V.random, 2, nrun = 10, seed = 123456)
# plot measures on the same graph
#pdf ('RegulonActivity_byTimePoint_nmf_single_method_over_range_of_ranks_randomized.pdf', width= 20, height = 18)
plot (estim.r, estim.r.random)
#dev.off()

# nmf results
res <- nmf(sub, 2, seed = seed)

# visualise nmf results
#pdf ('RegulonActivity_byTimePoint_nmf_coefficient_matrix.pdf')
coefmap(res) 
basismap (res, annRow=list(basis=':basis'))
#dev.off()
# retrieve the fitted model
fit(res)
#<Object of class:NMFstd>
#features: 790 
#basis/rank: 8 
#samples: 152
# quality measures
summary (res)

# nmf matrices are sparse, metagenes can be characterized by a small group of genes
# those are determined based on their relative contribution to each metagene
feature_scores <- featureScore(res, method = 'kim')
summary (feature_scores)

# plot distribution of regulons feature scores
df <- data.frame (feature_scores)
ggplot (df, aes(x = feature_scores)) + 
  geom_histogram(binwidth=.1) + 
  geom_vline(xintercept = median (feature_scores, na.rm = T), color = 'red', linetype = 'dashed', size = 1)

# compute the scores and characterise each metagenes
# extract top 5 for each basis
#s <- extractFeatures(res, 5L)

# extract features that have a relative basis contribution above a threshold
s <- extractFeatures(res, 0.25, nodups = TRUE)
str(s)

# check identity of each rank
type_1 <- feature_scores[s[[1]]]
type_2 <- feature_scores[s[[2]]]

type1_dat <- sub_Scaled[rownames(sub_Scaled) %in% names(type_1), ]
type2_dat <- sub_Scaled[rownames(sub_Scaled) %in% names(type_2), ]
pdf ('../plots/nmf_corr_no_overlap_regulons_byTimePoints.pdf', width = 12)
pheatmap::pheatmap(type1_dat, fontsize_row=5, fontsize_col = 4, color=colorRampPalette(c("blue","white","red"))(100), breaks=seq(-3, 3, length.out = 100), treeheight_row=10, treeheight_col=10, border_color=NA)
pheatmap::pheatmap(type2_dat, fontsize_row=5, fontsize_col = 4, color=colorRampPalette(c("blue","white","red"))(100), breaks=seq(-3, 3, length.out = 100), treeheight_row=10, treeheight_col=10, border_color=NA)
dev.off()
```

```{r}
# correlated non overlapping regulons by Cell type
# plot by timepoint, cluster and cell type
sub = NULL; sub = regulonActivity_byCluster
common_1 <- intersect(rownames(sub), dat$Regulon1)
common_2 <- intersect(rownames(sub), dat$Regulon2)
common <- union (common_1, common_2)
sub <- sub[common, ]

pdf ('../plots/corr_no_overlap_regulons_byCluster.pdf', width  = 8, height = 15)
sub_Scaled <- t(scale(t(sub), center = T, scale=T))
pheatmap::pheatmap(sub_Scaled, #fontsize_row=3, 
                   color=colorRampPalette(c("blue","white","red"))(100), breaks=seq(-3, 3, length.out = 100), fontsize_row = 5, 
                   treeheight_row=10, treeheight_col=10, border_color=NA)
dev.off()

# NMF
seed= 123456
# run at multiple ranks and choose the one at which the cophenetic value starts to decrease
# Estimation of the rank: Consensus matrices computed from 10 runs for each value of r
estim.r <- nmf (sub, 2:10, nrun = 10, seed = seed)
#pdf ('RegulonActivity_byTimePoint_nmf_single_method_over_range_of_ranks.pdf', width = 20, height = 18)
plot(estim.r)
#consensusmap (estim.r, annCol = annotation)
#dev.off()

# randomize the data and recompute the rank
# shuffle the original data
V.random <- randomize (sub)
# estimate quality measures from the shuffled data using default nmf algorithm
estim.r.random <- nmf (V.random, 4, nrun = 10, seed = 123456)
# plot measures on the same graph
#pdf ('RegulonActivity_byTimePoint_nmf_single_method_over_range_of_ranks_randomized.pdf', width= 20, height = 18)
plot (estim.r, estim.r.random)
#dev.off()

# nmf results
res <- nmf(sub, 4, seed = seed)

# visualise nmf results
#pdf ('RegulonActivity_byTimePoint_nmf_coefficient_matrix.pdf')
coefmap(res) 
basismap (res, annRow=list(basis=':basis'))
#dev.off()
# retrieve the fitted model
fit(res)
#<Object of class:NMFstd>
#features: 790 
#basis/rank: 8 
#samples: 152
# quality measures
summary (res)

# nmf matrices are sparse, metagenes can be characterized by a small group of genes
# those are determined based on their relative contribution to each metagene
feature_scores <- featureScore(res, method = 'kim')
summary (feature_scores)

# plot distribution of regulons feature scores
df <- data.frame (feature_scores)
ggplot (df, aes(x = feature_scores)) + 
  geom_histogram(binwidth=.1) + 
  geom_vline(xintercept = median (feature_scores, na.rm = T), color = 'red', linetype = 'dashed', size = 1)

# compute the scores and characterise each metagenes
# extract top 5 for each basis
#s <- extractFeatures(res, 5L)

# extract features that have a relative basis contribution above a threshold
s <- extractFeatures(res, 0.25, nodups = TRUE)
str(s)

# check identity of each rank
type_1 <- feature_scores[s[[1]]]
type_2 <- feature_scores[s[[2]]]
type_3 <- feature_scores[s[[3]]]
type_4 <- feature_scores[s[[4]]]

type1_dat <- sub_Scaled[rownames(sub_Scaled) %in% names(type_1), ]
type2_dat <- sub_Scaled[rownames(sub_Scaled) %in% names(type_2), ]
type3_dat <- sub_Scaled[rownames(sub_Scaled) %in% names(type_3), ]
type4_dat <- sub_Scaled[rownames(sub_Scaled) %in% names(type_4), ]

pdf ('../plots/nmf_corr_no_overlap_regulons_byCluster.pdf', width = 12)
pheatmap::pheatmap(type1_dat, fontsize_row=5, fontsize_col = 4, color=colorRampPalette(c("blue","white","red"))(100), breaks=seq(-3, 3, length.out = 100), treeheight_row=10, treeheight_col=10, border_color=NA)
pheatmap::pheatmap(type2_dat, fontsize_row=5, fontsize_col = 4, color=colorRampPalette(c("blue","white","red"))(100), breaks=seq(-3, 3, length.out = 100), treeheight_row=10, treeheight_col=10, border_color=NA)
pheatmap::pheatmap(type3_dat, fontsize_row=5, fontsize_col = 4, color=colorRampPalette(c("blue","white","red"))(100), breaks=seq(-3, 3, length.out = 100), treeheight_row=10, treeheight_col=10, border_color=NA)
pheatmap::pheatmap(type4_dat, fontsize_row=5, fontsize_col = 4, color=colorRampPalette(c("blue","white","red"))(100), breaks=seq(-3, 3, length.out = 100), treeheight_row=10, treeheight_col=10, border_color=NA)
dev.off()
```

```{r}
# save regulons-targets per cell type
# read regulons specific per cell type (picked up vidually from heatmap)
microglia = read.delim ('../data/microglia_regulons', header = FALSE, stringsAsFactors = FALSE); microglia = microglia$V1

# grab relevant data from incidence matrix to know target genes/regulon
microglia_dat = incidMat[rownames(incidMat) %in% microglia, ]

# convert to long format and remove any zero entry
df = NULL; df = reshape2::melt(microglia_dat)
df = df[!df$value == 0, ]

# convert back towide format
df <- spread(df, key = Var2, value = value)
rownames(df) = df$Var1;  df = df[, -1]

# create list for each regulon (TF <-> targets)
microglia_regulons = asplit(df, 1)
# discard NA entries
microglia_regulons = lapply (microglia_regulons, function (x) x[!is.na(x)])
```

```{r}
# convert mouse gene symbols to human gene symbols
# https://www.r-bloggers.com/converting-mouse-to-human-gene-names-with-biomart-package/
library (biomaRt)
musGenes <- names(microglia_regulons$Egr1)

# trim white spaces at beginning and end
trim <- function (x) gsub ("^\\s+|\\s+$", "", x)
musGenes = trim(musGenes)
# Basic function to convert human to mouse gene names
convertMouseGeneList <- function(x){
 
require("biomaRt")
human = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
mouse = useMart("ensembl", dataset = "mmusculus_gene_ensembl")
 
genesV2 = getLDS(attributes = c("mgi_symbol"), filters = "mgi_symbol", values = x , mart = mouse, attributesL = c("hgnc_symbol"), martL = human, uniqueRows=T) 
humanx <- unique(genesV2[, 2])
 
# Print the first 6 genes found to the screen
print(head(humanx))
return(humanx)
}
genes <- convertMouseGeneList(musGenes)
length (genes)
write.table (genes, file = '../data/TFBS/microglia_Egr1.txt', sep = '\t', quote = FALSE, row.names = FALSE)
```

```{r}
# convert gene symbols to gene IDs
geneSymbols = NULL
geneSymbols = read.delim ('../data/TFBS/microglia_Egr1.txt', stringsAsFactors = FALSE); geneSymbols = geneSymbols$x

geneIDs2 <- ensembldb::select(EnsDb.Hsapiens.v79, keys= geneSymbols, keytype = "SYMBOL", columns = c("SYMBOL","GENEID"))
write.table (geneIDs2, file = '../data/TFBS/microglia_Egr1.txt', sep = '\t', quote  = FALSE, row.names = FALSE)
```

